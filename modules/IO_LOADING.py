#!/usr/bin/env python

# The name of this file
__name__ = "IPRO Suite Input / Output Loading Functions"
# Documentation
__doc__ = """
Written in 2013 by Robert Pantazes of the Costas Maranas Lab in the Chemical
Engineering Department of the Pennsylvania State University

This file contains functions for loading information from the
Experiment_Details.txt file"""

# Include standard PYTHON modules
import os
import sys
# Include other I/O functions
import IO_FUNCTIONS as FUNCTIONS
import IO_CHECK as CHECK
# Include the MOLECULES and EXPERIMENT modules
from STANDARDS import *
import MOLECULES
import EXPERIMENT

def load_Experiment_Details():
    """Try to load the Experiment_Details.txt file"""
    # Store the information from the file here
    data = {}
    # Try to open the file
    try:
        f = open("Experiment_Details.txt", "r")
    except IOError:
        text = "There is no Experiment Details file"
        raise FUNCTIONS.IPRO_IOError(text)
    # Go through the contents of the file
    for line in f:
        # Get the index of the first ':'. If there isn't one, skip this line
        try:
            i = line.index(':')
        except ValueError:
            continue
        # Split the line on that value
        attribute = line[:i].strip()
        info = line[i+1:].strip()
        # Store the attribute in data, as appropriate
        # If this is the first instance of this attribute occuring, store it as
        # a string
        if attribute not in data:
            data[attribute] = info
        else:
            # if the current value is a string, change it to a list
            if isinstance(data[attribute], str):
                data[attribute] = [data[attribute]]
            # Store the new information in the list
            data[attribute].append(info)
    # close the file and return the data
    f.close()
    return data

def standard_load(attribute, experiment, data, type):
    """A standard function for loading attributes in an experiment"""
    # Store any errors generated by the function here
    error = ''
    # If the attribute should be a list, it will be stored missing a 's' in the
    # data dictionary
    if type == "list":
        term = attribute[:-1]
    else:
        term = attribute
    # If the attribute isn't in the data
    if term not in data:
        error = "\nThere is no " + term + " information."
    # Otherwise, figure out how to store that data
    else:
        # If it should be a list, change it to a list if it is a string (i.e. if
        # there was only a single entry)
        if type == "list" and isinstance(data[term], str):
            data[term] = [data[term]]
        # If the information is in a list but shouldn't be
        if isinstance(data[term], list) and type != "list":
            error = "\nThere are multiple " + term + " entries."
        else:
            # Go through the values and try to modify them
            if type == "float":
                try:
                    data[term] = float(data[term])
                except ValueError:
                    error = "\n" + term + " must be a floating point number"
            elif type == "integer":
                try:
                    data[term] = int(data[term])
                except ValueError:
                    error = "\n" + term + " must be an integer"
            elif type == "bool":
                if data[term] in FUNCTIONS.yesNo:
                    if data[term] in FUNCTIONS.yes:
                        data[term] = True
                    else:
                        data[term] = False
                else:
                    error = "\n" + term + " must indicate either True or False"
            elif type == "string":
                # If the value is a string, it may have an acceptable None
                # value. Check for that instance
                if data[term].lower() == "none":
                    data[term] = None
    # If there isn't an error, try to store the data
    if error == '':
        try:
            experiment[attribute] = data[term]
        # If any IPRO Suite Error occurs, store that information
        except IPRO_Error as problem:
            error += str(problem)
    return error

def basic_info(experiment, data):
    """Load the basic information into the Experiment"""
    # Store any generated errors here
    errors = ''
    # Go through the basic pieces of information for the experiment
    for attribute in ['User', 'Type', 'Name', 'File Format', 'Force Field', \
                      'Folder']:
        errors += standard_load(attribute, experiment, data, "string")
    # Make sure the Folder is valid
    if errors == '':
        if os.getcwd() + "/" != experiment["Folder"]:
            errors += "\nThe Experiment is not located in this folder:\n"
            errors += experiment["Folder"]
    if errors != '':
        raise FUNCTIONS.IPRO_IOError(errors)

def CHARMM_info(experiment, data):
    """Load the information about how to use CHARMM"""
    # Store any errors generated here
    errors = ''
    # Only do this if the Experiment is using the CHARMM force field
    if experiment["Force Field"] == "CHARMM":
        # Load the attributes that should be lists
        for attribute in ['CHARMM Topology Files', 'CHARMM Parameter Files', \
                          'CHARMM Energy Terms']:
            errors += standard_load(attribute, experiment, data, "list")
        # And the attribute that should be an integer
        errors += standard_load("CHARMM Iterations", experiment, data,"integer")
    # In the basic info function, an error was raised. But an error can be
    # raised by the experiment if there is a problem finding ANY of a large
    # number of pieces of information
    return errors

def docking_info(experiment, data):
    """Load information about how to run docking"""
    # Store errors here
    errors = ''
    # Go through the attributes that should be integers
    for attribute in ['Docking Frequency', 'Docking Iterations']:
        errors += standard_load(attribute, experiment, data, "integer")
    # And the ones that should be floating point numbers
    for attribute in ['Docking SD Movements', 'Docking SD Rotations', \
                      'Docking Start Temp', 'Docking End Temp']:
        errors += standard_load(attribute, experiment, data, "float")
    return errors

def IPRO_info(experiment, data):
    """Load the information about how to run IPRO"""
    # Store errors here
    errors = ''
    # Each of these four attributes has a different type
    errors += standard_load("IPRO Iterations", experiment, data, "integer")
    errors += standard_load("IPRO Annealing Temperature", experiment, data, \
                            "float")
    errors += standard_load("Annealing Sharing", experiment, data, "bool")
    errors += standard_load("Energy Calculation", experiment, data, "string")
    return errors

def refinement_info(experiment, data):
    """Load information about how to run structure refinements"""
    # Store errors here
    errors = ''
    # If this is a mutator experiment, say that refinements should be done
    if "Type" in experiment and experiment["Type"] == "Mutator":
        data["Do Refinement"] = "yes"
    errors += standard_load("Do Refinement", experiment, data, "bool")
    for attribute in ['Refinement Iterations', 'Ensemble Number']:
        errors += standard_load(attribute, experiment, data, "integer")
    return errors

def rotamer_info(experiment, data):
    """Load information about how rotamers should be used"""
    # Store the errors here
    errors = ''
    # Store the information that should be strings
    for attribute in ['Rotamer Library', 'Packing Method', 'Packing Selection']:
        errors += standard_load(attribute, experiment, data, "string")
    # And those that should be floats
    for attribute in ['Rotamer Window', 'Packing Cutoff']:
        errors += standard_load(attribute, experiment, data, "float")
    # And the single integer
    errors += standard_load("Max Rotamer Number", experiment, data, "integer")
    return errors

def solvation_info(experiment, data):
    """Load the implicit solvation information"""
    # Store errors here
    errors = ''
    # Get whether or not solvation should be used
    errors += standard_load("Use Solvation", experiment, data, "bool")
    # If there's no error
    if errors == '':
        # Load specifications for individual functions
        for attribute in ['Relaxation Solvation', 'Perturbation Solvation', \
                          'Energy Solvation']:
            if attribute in data:
                errors += standard_load(attribute, experiment, data, "bool")
            else:
                experiment[attribute] = experiment["Use Solvation"]
        # If solvation is being used
        if experiment["Use Solvation"]:
            # Get the solvation type
            errors += standard_load("Solvation Type", experiment, data,"string")
            # If there were no errors and LK solvation is being used
            if errors == '' and experiment["Solvation Type"] == \
            "Lazaridis-Karplus":
                errors += standard_load("LK Solvation Files", experiment, \
                                        data, "list")
    return errors

# That is the end of the information that is loaded using the standard load
# funciton. The remaining information has to be more carefully parsed
def Molecules(experiment, data):
    """Load the information about which Molecules are being used"""
    # Store errors here
    errors = ''
    # If there is no Molecule information
    if "Molecule" not in data:
        errors += "\nThere is no Molecule information"
    else:
        # If the information is a string, change it to a list
        if isinstance(data["Molecule"], str):
            data["Molecule"] = [data["Molecule"]]
        # Store the Molecules in this list
        molecules = []
        # Go through each entry in that list
        for line in data["Molecule"]:
            # Split the line on whitespace
            items = line.split()
            # The line should be organized as follows
            # Molecule mn1 from file fn is DESIGN Molecule mn2
            # 0        1   2    3    4  5  6      7        8
            if len(items) != 9:
                errors += "\nThe following is not a properly formatted Molecule"
                errors += " declaration:\n" + line
                continue
            # Get the information
            mn1 = items[1]
            fn = items[4]
            ds = items[6]
            if ds.lower() == "design":
                design = True
            elif ds.lower() == "target":
                design = False
            else:
                errors += "\n" + ds + " is not a declaration of a Molecule's " \
                       + "Design status."
                continue
            mn2 = items[8]
            # Try to load the relevant Molecule. Generate its expected name
            fileName = "Molecule" + mn2
            if experiment["File Format"] == "PDB":
                fileName += ".pdb"
            else:
                text = "The LOADING Molecules function does not support the "
                text += experiment["File Format"] + " file format."
                raise FUNCTIONS.IPRO_IOError(text)
            # Load the Molecule
            try:
                f = CHECK.for_file(fileName, "./", True)
            except FUNCTIONS.IPRO_IOError as error:
                errors += str(error)
                continue
            lines = f.readlines()
            f.close()
            # Try to make a Molecule
            try:
                molecule = MOLECULES.Molecule(lines, None, None, mn2, design, \
                           experiment['Force Field'], experiment['File Format'])
            except MOLECULES.MoleculeError as error:
                errors += str(error)
            # Store the molecule in the list
            molecules.append([fn, mn1, molecule])
        # Store the Molecules in the Experiment
        try:
            experiment["Molecules"] = molecules
        except IPRO_Error as error:
            errors += str(error)
    return errors

def Dimers(experiment, data):
    """Load the information about which Molecules are Dimers"""
    # Store any errors here
    errors = ''
    # There doesn't have to be dimer information
    if "Dimers" in data:
        # If it is a string, make it a list
        if isinstance(data["Dimers"], str):
            data["Dimers"] = [data["Dimers"]]
        # Store the dimers here
        dimers = []
        # Go through the text
        for line in data["Dimers"]:
            # It should be organized as follows
            # Molecules mn1 and mn2
            items = line.split()
            if len(items) != 4:
                errors += "\nThe following line is not a properly formatted "
                errors += "Dimer specification:\n" + line
                continue
            dimers.append([items[1], items[3]])
        # Try to store the dimers
        try:
            experiment["Dimers"] = dimers
        except IPRO_Error as error:
            errors += str(error)
    return errors

def DesignPositions(experiment, data):
    """Load the Design Position information"""
    # Store errors here
    errors = ''
    # If the Design Position information is missing
    if "Design Position" not in data:
        errors += "\nThere is no Design Position information"
    else:
        # if the information is a single string, put it in a list
        if isinstance(data["Design Position"], str):
            data["Design Position"] = [data["Design Position"]]
        # Store the Design Position information in this dictionary
        positions = {}
        # go through the specificiations
        for line in data["Design Position"]:
            # Should be organized as:
            # Residue rn in Molecule mn
            items = line.split()
            if len(items) != 5:
                errors += "\nThe following line is not a valid Design Position "
                errors += "specification:\n" + line
                continue
            if items[4] not in positions:
                positions[items[4]] = []
            positions[items[4]].append(items[1])
        # Store the Design Position information
        try:
            experiment["Design Positions"] = positions
        except IPRO_Error as error:
            errors += str(error)
    return errors

def EpitopePositions(experiment, data):
    """Load the Epitope Position information"""
    # Store errors here
    errors = ''
    # If the Epito Position information is missing
    if "Epitope Position" not in data:
        errors += "\nThere is no Epitope Position information"
    else:
        # if the information is a single string, put it in a list
        if isinstance(data["Epitope Position"], str):
            data["Epitope Position"] = [data["Epitope Position"]]
        # Store the Epitope Position information in this dictionary
        positions = {}
        # go through the specificiations
        for line in data["Epitope Position"]:
            # Should be organized as:
            # Residue rn in Molecule mn
            items = line.split()
            if len(items) != 5:
                errors += "\nThe following line is not a valid Epitope Position "
                errors += "specification:\n" + line
                continue
            if items[4] not in positions:
                positions[items[4]] = []
            positions[items[4]].append(items[1])
        # Store the Design Position information
        try:
            experiment["Epitope Positions"] = positions
        except IPRO_Error as error:
            errors += str(error)
    return errors

def DesignGroups(experiment, data):
    """Load the information defining the Design Groups"""
    # Store errors here
    errors = ''
    # If the data is missing
    if "Design Group" not in data:
        errors += "\nThe Design Group information is missing"
    else:
        # Make sure it is a list
        if isinstance(data["Design Group"], str):
            data["Design Group"] = [data["Design Group"]]
        # Store the Design Groups in this list
        groups = []
        # Go through the lines
        for line in data["Design Group"]:
            # Should be organized as
            # objective binding to Molecules: mn1 mn2 etc.
            items = line.split()
            if len(items) < 4 or items[0].lower() not in ['improve','maintain',\
            'reduce', 'eliminate'] or items[1] != "binding" or items[2] != "to"\
            or items[3] != "Molecules:":
                errors += "\nThe following line is not a valid Design Group "
                errors += "specification:\n" + line
                continue
            # Store the information
            group = [items[0].lower()]
            group.extend(items[4:])
            groups.append(group)
        # Store the Design Groups
        try:
            experiment["Design Groups"] = groups
        except IPRO_Error as error:
            errors += str(error)
    return errors

def PermittedKinds(experiment, data):
    """Load information about how Residues may mutate"""
    # Store errors here
    errors = ''
    # There does not have to be this data
    if "Permitted Kinds" in data:
        # Store them here
        permissions = {}
        # Make sure the data is a list
        if isinstance(data["Permitted Kinds"], str):
            data["Permitted Kinds"] = [data["Permitted Kinds"]]
        # Go through the list
        for line in data["Permitted Kinds"]:
            # It should be organized like this
            # Residue rn in Molecule mn: aa1 aa2 etc
            items = line.split()
            if len(items) < 6:
                errors += "\nThe following is not a valid Permitted Kinds "
                errors += "specification:\n" + str(line)
                continue
            mn = items[4][:-1]
            if mn not in permissions:
                permissions[mn] = {}
            if items[1] in permissions[mn]:
                errors += "\nThere are multiple listings of Permitted Kinds "
                errors += "for Residue " + items[1] + " in Molecule " + mn
                continue
            permissions[mn][items[1]] = items[5:]
        # Store the permissions
        try:
            experiment["Permitted Kinds"] = permissions
        except IPRO_Error as error:
            errors += str(error)
    return errors

def Mutants(experiment, data):
    """Load information about Mutations"""
    # Store errors here
    errors = ''
    # If the information is missing
    if "Mutation" not in data:
        errors += "\nThe Mutation information is missing"
    else:
        # Store the mutants in this dictionary initially
        mutants = {}
        # If the information is not in a list
        if isinstance(data["Mutation"], str):
            data["Mutation"] = [data["Mutation"]]
        # go through the entries
        for line in data["Mutation"]:
            # Should be organized as
            # Mutant N: Mutate Residue rn in Molecule mn to aa
            # 0      1  2      3       4  5  6        7  8  9
            items = line.split()
            if len(items) != 10:
                errors += "\nThe following is not a valid Mutation "
                errors += "specification:\n" + line
                continue
            N = int(items[1][:-1])
            if N not in mutants:
                mutants[N] = []
            mutants[N].append([items[7], items[4], items[9]])
        # Convert that to a list
        mutations = mutants.keys()
        mutations.sort()
        final = []
        for N in mutations:
            final.append(mutants[N])
        # Try to store that list
        try:
            experiment["Mutants"] = final
        except IPRO_Error as error:
            errors += str(error)
    # If there are no errors, store each mutated Residue as a Design Position
    if errors == '':
        positions = {}
        for mutant in experiment["Mutants"]:
            for mutation in mutant:
                mn = mutation[0]
                rn = mutation[1]
                if mn not in positions:
                    positions[mn] = []
                if rn not in positions[mn]:
                    positions[mn].append(rn)
        try:
            experiment["Design Positions"] = positions
        except FUNCTIONS.IPRO_IOError as error:
            errors += str(error)
    return errors

def fixedAtoms(experiment, data):
    """Load the Atoms that may never move"""
    # Store errors here
    errors = ''
    # There doesn't have to be this information
    if "Fixed Atoms" in data:
        # Make sure it is a list
        if isinstance(data["Fixed Atoms"], str):
            data["Fixed Atoms"] = [data["Fixed Atoms"]]
        # Store the fixed Atoms here
        fixed = {}
        # Loop through the lines
        for line in data["Fixed Atoms"]:
            # Should be formatted as 
            # In Residue rn of Molecule mn in all Design Groups: aa1 aa2 etc
            # OR
            # In Residue rn of Molecule mn in Design Group gn: aa1 aa2 etc
            # 0  1       2  3  4        5  6  7      8     9   10  11  
            items = line.split()
            if len(items) < 11:
                errors += "\nThe following is not a valid Fixed Atoms "
                errors += "specification:\n" + line
                continue
            # Get the 
            if items[7].lower() == 'all':
                gn = 'all'
            else:
                try:
                    gn = int(items[9][:-1])
                except ValueError:
                    errors += "\nThe following is not a validly formatted Fixed"
                    errors += " Atoms specification:\n" + line
                    continue
            mn = items[5]
            rn = items[2]
            # Prep the fixed dictionary
            if gn not in fixed:
                fixed[gn] = {}
            if mn not in fixed[gn]:
                fixed[gn][mn] = {}
            # If there is already an entry for that Residue
            if rn in fixed[gn][mn]:
                errors += "\nThere are multiple Fixed Atoms entries for "
                errors += line.split(":")[0][3:]
                continue
            # Store the Atoms
            fixed[gn][mn][rn] = items[10:]
        # Try to store the information
        if fixed != {}:
            # Check the restraints
            try:
                CHECK.fixedAtoms(fixed, experiment)
                # If the check was passed, store the information
                if "Restraints" not in experiment:
                    experiment["Restraints"] = {}
                experiment["Restraints"]["Fixed Atoms"] = fixed
            except FUNCTIONS.IPRO_IOError as error:
                errors += str(error)
    return errors

def position_restraints(experiment, data):
    """Load information restraining Atom positions"""
    # Store errors here
    errors = ''
    # This information does not have to exist
    if "Position Restraint" in data:
        # Make sure it is a list
        if isinstance(data["Position Restraint"], str):
            data["Position Restraint"] = [data["Position Restraint"]]
        # Store the restraints in this list
        restraints = []
        # Go through each line
        for line in data["Position Restraint"]:
            # The line formatting depends on the force field, so here are the
            # options
            # CHARMM
            # Atom an in Residue rn in Molecule mn in Design Group gn, using a
            # force constant of fn, to Design Group gn2
            # 0    1  2  3       4  5  6        7  8  9      10    11  12    13
            # 14    15       16 17  18 19     20    21
            # Currently there are no other force fields
            # For most options, can say 'all (Atoms) in' instead of (Atom) an in 
            # Can also say 'its initial position' instead of 'Design Group gn2'
            items = line.split()
            if experiment["Force Field"] == "CHARMM":
                if len(items) != 22:
                    errors += "\nThe following line is not a valid CHARMM "
                    errors += "position restraint specification:\n" + line
                    continue
            # If the force field isn't supported
            else:
                text = "The LOADING position restraints function does not "
                text += "support the " + experiment["Force Field"] + " force "
                text += 'field'
                raise FUNCTIONS.IPRO_IOError(text)
            # Get the Molecule information
            if items[0].lower() == 'all':
                an = 'all'
            else:
                an = items[1]
            if items[3].lower() == 'all':
                rn = 'all'
            else:
                rn = items[4]
            if items[6] == 'all':
                mn = 'all'
            else:
                mn = items[7]
            if items[9] == 'all':
                gn = 'all'
            else:
                try:
                    gn = int(items[11][:-1])
                except ValueError:
                    errors += "\nThe following is not a validly formatted "
                    errors += "position restraint:\n" + line
                    continue
            # Put that in a restraint
            restraint = [gn, mn, rn, an]
            # Have a different method based on force field
            if experiment["Force Field"] == "CHARMM":
                # Store the force constant
                try:
                    restraint.append(float(items[17][:-1]))
                except ValueError:
                    errors += "\nThe following line doesn't contain a force "
                    errors += "constant:\n" + line
                    continue
            # Determine if the restraint is to a particular position or its
            # initial position
            if items[19].capitalize() == "Design":
                try:
                    restraint.append(int(items[21]))
                except ValueError:
                    errors += "\nThe following position restraint isn't "
                    errors += "formatted properly:\n" + line
                    continue
            # Store the restraint
            restraints.append(restraint)
        # Check the restraints
        try:
            CHECK.position_restraints(restraints, experiment)
            # Store the restraint
            if "Restraints" not in experiment:
                experiment["Restraints"] = {}
            experiment["Restraints"]["Position"] = restraints
        # If there was an error checking the restraints, show that
        except FUNCTIONS.IPRO_IOError as error:
            errors += str(error)
    return errors

def distance_restraints(experiment, data):
    """Load the information about restraints on the distances between Atoms"""
    # Store errors here
    errors = ''
    # There doesn't have to be this information
    if "Distance Restraint" in data:
        # Make sure it is a list
        if isinstance(data["Distance Restraint"], str):
            data["Distance Restraint"] = [data["Distance Restraint"]]
        # Store the restraints in this list
        restraints = []
        # Go through the lines of text
        for line in data["Distance Restraint"]:
            # The formatting is dependent on the force field
            # CHARMM
            # Between Atom an1 in Residue rn1 in Molecule mn1 and Atom an2 in
            # Residue rn2 in Molecule mn2 in Design Group gn KMIN: N1 RMIN: N2
            # KMAX: N3 RMAX: N4 FMAX: N5
            # 0       1    2   3  4       5   6  7        8   9   10   11  12
            # 13      14  15 16       17  18 19     20    21 22    23 24    25
            # 26    27 28    29 30    31
            # There are currently no other force fields
            items = line.split()
            if experiment["Force Field"] == "CHARMM":
                if len(items) != 32:    
                    errors += "\nThe following is not a valid CHARMM distance "
                    errors += "restraint specification:\n" + line
                    continue
            else:
                text = "The LOADING distance restraints function does not "
                text += "support the " + experiment["Force Field"]
                text += " force field."
                raise FUNCTIONS.IPRO_IOError(text)
            # Start assembling the information
            if items[19].lower() == 'all':
                gn = 'all'
            else:
                try:
                    gn = int(items[21])
                except ValueError:
                    errors += "\nThe following is not a validly formatted "
                    errors += "distance restraint:\n" + line
                    continue
            restraint = [gn, [items[8], items[5], items[2]], [items[17], \
                         items[14], items[11]]]
            # Store the remaining information based on the force field
            if experiment["Force Field"] == "CHARMM":
                problem = False
                for i in [23, 25, 27, 29, 31]:
                    try:
                        restraint.append(float(items[i]))
                    except ValueError:
                        errors += "\nThe following is not a validly formatted "
                        errors += "CHARMM position restraint:\n" + line
                        problem = True
                        break
                if problem:
                    continue
            # Store the restraint
            restraints.append(restraint)
        # Check the restraints
        try:
            CHECK.position_restraints(restraints, experiment)
            if "Restraints" not in experiment:
                experiment["Restraints"] = {}
            experiment["Restraints"]["Distance"] = restraints
        # If there was an error, store that information
        except FUNCTIONS.IPRO_IOError as error:
            errors += str(error)
    return errors

def dihedral_restraints(experiment, data):
    """Load the information about dihedral angle restraints"""
    # Store errors here
    errors = ''
    # There doesn't have to be any restraints
    if "Dihedral Restraint" in experiment:
        # Make sure it is a list
        if isinstance(data["Dihedral Restraint"], str):
            data["Dihedral Restraint"] = [data["Dihedral Restraint"]]
        # Store the restraints in this list
        restraints = []
        # Go through the lines
        for line in data["Dihedral Restraint"]:
            # CHARMM formatting (this is long because there are 4 Atom
            # specifications)
            # Between Atom an1 in Residue rn1 in Molecule mn1, Atom an2 in
            # Residue rn2 in Molecule mn2, Atom an3 in Residue rn3 in Molecule
            # mn3, and Atom an4 in Residue rn4 in Molecule mn4 in Design Group
            # gn using a force constant of N1 to a minimum angle of N2
            # 0       1    2   3  4       5   6  7        8    9    10  11
            # 12      13  14 15       16   17   18  19 20      21  22 23
            # 24   25  26   27  28 29      30  31 32       33  34 35     36
            # 37 38    39 40   41       42 43 44 45 46     47    48 49
            items = line.split()
            if experiment["Force Field"] == "CHARMM":
                if len(items) != 50:
                    errors += "\nThe following is not a validly formatted "
                    errors += "CHARMM Dihedral Restraint:\n" + line
                    continue
            else:
                text = "The LOADING dihedral restraints function does not "
                text += "support the " + experiment["Force Field"]
                text += " force field."
                raise FUNCTIONS.IPRO_IOError(text)
            # Get the Design Group specification
            if items[35].lower() == 'all':
                gn = 'all'
            else:
                try:
                    gn = int(items[37])
                except ValueError:
                    errors += "\nThe following is not a validly formatted "
                    errors += "dihedral restraint:\n" + line
                    continue
            # Store the information
            restraint = [gn, [items[8][:-1], items[5], items[2]], \
                             [items[16][:-1], items[13], items[10]], \
                             [items[24][:-1], items[21], items[18]], \
                             [items[33], items[30], items[27]]]
            # Store the remaining information based on force field
            if experiment["Force Field"] == "CHARMM":
                problem = False
                for i in [43, 49]:
                    try:
                        restraint.append(float(items[i]))
                    except ValueError:
                        errors += "\nThe following is not a validly formatted "
                        errors += "dihedral restraint:\n" + line
                        problem = True
                        break
                if problem:
                    continue
            # Store the restraint
            restraints.append(restraint)
        # Check and store the restraints
        try:
            CHECK.dihedral_restraints(restraints, experiment)
            if "Restraints" not in experiment:
                experiment["Restraints"] = {}
            experiment["Restraints"]["Dihedral"] = restraints
        # If there was a problem, store that error
        except FUNCTIONS.IPRO_IOError as error:
            errors += str(error)
    return errors

def Restraints(experiment, data):
    """Load the information about structure restraints"""
    # Store generated errors here
    errors = ''
    # Go through the various types of restraints
    errors += fixedAtoms(experiment, data)
    errors += position_restraints(experiment, data)
    errors += distance_restraints(experiment, data)
    errors += dihedral_restraints(experiment, data)
    return errors

